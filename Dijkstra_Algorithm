Dijkstra Algorithm:

为了跟踪从开始节点到每个目的地的总成本，我们将使用定点中的dist实例变量。dist实例变量将包含从开始到 某一个顶点的最小权重路径的当前总权重。该算法对图中的每个顶点重复一次；然而，我们在顶点上迭代的顺序由优先级队列（Priority Queue）控制。用于确定Priority Queue中对象序列的值为dist。当首次创建顶点时，dist被设置为非常大的数。理论上，你将dist设置为无穷大，但在实践中，我们只将它设置为一个数字，大于任何真正的距离，我们将在问题中试图解决。

Dijkstra Algorithm：该算法是基于 广度优先搜索（BFS）来解决有向或无向图的单源最短路问题（single-source shortest path problem）。算法最终会得到一个最短路径树。该算法经常用于路由算法或者作为其他图算法的一个子模块。

Dijkstra算法适用场景：
1. 有向或无向
2. 单源最短路问题
3. 路径权重不能为负

算法思想：
Dijkstra算法采用的是Greedy Strategy，先声明一个数组 dis 来存放 源点 到各个顶点的最短距离和一个 保存已经找到了最短路径的顶点的集合 T 。 初始时，源点 s 的路径权重为 0，即 dis[s] = 0 。 若对于顶点 s ，存在能够直接到达的边 (s, m)，则将 dis[m] 设为 w (s, m)， 同时将其他所有 s 不能够直接到达的顶点 的路径设为 无穷大。 初始时，集合 T 只有顶点 s
然后， 从 dis 数组中挑选出 最小值，该值就是 源点 s 到 该值对应的顶点的最短路径， 并且将该点加入到 T 中， 此时就完成了一个顶点的搜索。
然后我们需要看，新加入的顶点是否可以到达其他顶点，并且看 通过该顶点 到达其他点的路径长度 是否比源点 直接到达 更短，如果是，就替换掉这些顶点 在 dis 中的值。
然后， 又从 dis 中找到最小值，重复上述操作，直到 T 中包含了图的 所有顶点为止。

参考： https://blog.csdn.net/qq_35644234/article/details/60870719







