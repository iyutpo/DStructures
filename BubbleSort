冒泡排序：
经典的冒泡排序需要对数组进行多次遍历。每次都要对数组中相邻的两个元素（也叫item）进行比较，如果是 前面元素较大，后面元素较小，就互换（swap）这两个元素的位置；否则就保持二者位置不变。
由于需要两两元素进行比较，所以这需要对数据进行一次遍历，且进行了 n-1 次比较（n为数组元素的个数）。假设现在我们有这样一个数组：alist = [70,10,8,3,20,35]，我们先比较 70和10 这两个元素，由于 前面的元素（70）> 后面的元素（10），所以互换，然后得到 [10,70,8,3,20,35], ..., [10,8,3,20,35,70]。因此第一次进行该遍历，就会将最大元素“冒泡”到数组最后；第二次进行该遍历，就会将次最大元素“冒泡”到数组的倒数第二位……

以此类推不难想象出，我们将第一层遍历执行 n 次，就能得到排序后的数组。为此我们还需要第二层遍历。注意，由于每进行一次第一层遍历，都会有一个 当前最大的元素被放置到正确的位置，所以第二层遍历的次数也因此 - 1。例如，当进行一次第一层遍历后，最大元素（70）被放到正确位置，此时需要进行遍历的元素个数就变成 n - 1个。

def bubbleSort(alist):
  for bar in range(len(alist) - 1, 0, -1):   # 第二层遍历，表示当前有多少元素要参与两两比较
    for i in range(bar):                     # 第一层便利，用于对未排序的部分进行两两比较
      if alist[i] > alist[i+1]:              # 如果前一个元素较大，就互换
        alist[i], alist[i+1] = alist[i+1], alist[i]
  return alist
